<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>3D Drone</title>

  <link rel="stylesheet" href="https://js.arcgis.com/4.32/esri/themes/light/main.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/map3d.css') }}">
</head>
<body>
  <div id="viewDiv"></div>
  <div id="minimapDiv"></div>
  <div id="minimapDiv2"></div>
  <div id="infoPanel"></div>
  <div id="screenFilter"></div>
  
    <div id="camerabox">
      <img style="bottom:0;left:0;z-index: -1;overflow-x: hidden;width:145%;"id="camerabox" src="{{cam_feed}}" alt="Kamera Görüntüsü">
      <div id="camerabox_box">
        <div id="switchLabel">Otomatik Odak</div>
        <label class="switch">
          <input type="checkbox">
          <span class="slider"></span>
        </label>
      </div>
      <div id="infoPanelCam"></div>

      <div id="liveLabel">
        <div class="dot"></div>
        Canlı Yayın
      </div>
      <div id="connectionLabel">
        
      </div>
    </div>
  

  <div id="altitudeContainer">
    <div id="altitudeScroller">
      <div id="altitudeLabels"></div>
    </div>
    <div id="targetLine"></div>
    <div id="leftSolidLine"></div>
    <div id="rightSolidLine"></div>
    <div id="altitudeValueBox">50 m</div>
  </div>

  <div id="gaugeContainer">
    <img src="static/img/Gösterge.png"
         style="position:absolute; bottom:5px; left:3px; width:140px; height:140px;">
    <canvas id="gaugeCanvas" width="80%" height="80"></canvas>
    <div id="speedText"></div>
  </div>

  <div id="topRightBox">
    <iframe src="{{ url_for('riskmap')}}" width="150px" height="150px"></iframe>
  </div>

  <div id="topCenterBox">
    <iframe src="{{ url_for('sensors') }}"></iframe>
  </div>

  <script src="https://js.arcgis.com/4.32/"></script>
  <script>
    
    require([
      "esri/Map", "esri/views/SceneView", "esri/views/MapView",
      "esri/layers/GraphicsLayer", "esri/Graphic", "esri/geometry/Point",
      "esri/symbols/SimpleMarkerSymbol",
      "esri/layers/SceneLayer"
    ], function(
      Map, SceneView, MapView, GraphicsLayer, Graphic, Point,
      SimpleMarkerSymbol, SceneLayer
    ) {

      const mainMap = new Map({ basemap: "hybrid", ground: "world-elevation" });
      const miniMap = new Map({ basemap: "dark-gray-vector" });

      const buildingLayer = new SceneLayer({
        url: "https://basemaps3d.arcgis.com/arcgis/rest/services/OpenStreetMap3D_Buildings_v1/SceneServer",
        renderer: {
          type: "simple",
          symbol: {
            type: "mesh-3d",
            symbolLayers: [{
              type: "fill",
              material: {
                color: "#708090"
              }
            }]
          }
        }
      });
      const treeLayer = new SceneLayer({
        url: "https://basemaps3d.arcgis.com/arcgis/rest/services/OpenStreetMap3D_Trees_Realistic_v1/SceneServer"
      });
      mainMap.add(buildingLayer);
      mainMap.add(treeLayer);

      const sceneView = new SceneView({
        container: "viewDiv",
        map: mainMap,
        camera: {}
      });

      const minimapView = new MapView({
        container: "minimapDiv",
        map: miniMap,
        center: [ 28.9802621, 41.0320231],
        zoom: 14,
        constraints: { rotationEnabled: false },
        ui: { components: [] }
      });
      const minimapView2 = new MapView({
        container: "minimapDiv2",
        map: miniMap,
        center: [28.9802621, 41.0320231],
        zoom: 14,
        constraints: { rotationEnabled: false },
        ui: { components: [] }
      });

      const graphicsLayer = new GraphicsLayer({ elevationInfo: { mode: "relative-to-ground" } });
      mainMap.add(graphicsLayer);

      let altitude = 50;
      let dronePoint = new Point({
        x: 28.9802621,
        y: 41.0320231,
        z: altitude,
        spatialReference: { wkid: 4326 }
      });
      const droneSymbol = {
        type: "point-3d",
        symbolLayers: [{
          type: "object",
          resource: {
            href: "static/img/drone_model.glb"
          },
          height: 1,
          width: 4,
          depth: 4
        }]
      };
      const markerSymbol = new SimpleMarkerSymbol({
        style: "circle",
        color: "red",
        size: 10
      });

      const drone = new Graphic({ geometry: dronePoint, symbol: droneSymbol });
      const miniMarker = new Graphic({ geometry: dronePoint, symbol: markerSymbol });

      graphicsLayer.add(drone);
      minimapView.graphics.add(miniMarker);

      let prevPos = dronePoint.clone();
      let targetPos = new Point({
        x: prevPos.x + 0.0005,
        y: prevPos.y ,
        z: altitude + 0.0005,
        spatialReference: prevPos.spatialReference
      });

      const followDistance = 50;
      const tiltAngle = 75;
      const animDuration = 0.2;
      let isAnimating = false;

      const altitudeLabels = document.getElementById("altitudeLabels");
      altitudeLabels.innerHTML = "";
      for (let i = 0; i <= 100; i += 5) {
        const label = document.createElement("div");
        label.className = "altitudeLabel";
        label.textContent = `${i} m`;
        altitudeLabels.appendChild(label);
      }

      function updateAltitudeIndicator(currentAltitude) {
        const container = document.getElementById("altitudeContainer");
        const labelHeight = 30;
        const step = 5;
        const maxAltitude = 100;

        const clamped = Math.max(0, Math.min(currentAltitude, maxAltitude));
        const index = (maxAltitude - clamped) / step;
        const offset = index * labelHeight;
        const centerOffset = (container.clientHeight - labelHeight) / 2;
        altitudeLabels.style.transform = `translateY(${centerOffset - offset}px)`;

        if (currentAltitude > 100) {
          container.style.backgroundColor = "rgba(255, 0, 0, 0.5)";
          container.style.border = "2px solid red";
        } else {
          container.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
          container.style.border = "1px solid #aaa";
        }
      }

      function updateInfoPanel(fps) {
        const { x, y } = drone.geometry;
        document.getElementById("infoPanel").innerHTML = `
          <strong>Enlem:</strong> ${y.toFixed(6)}<br>
          <strong>Boylam:</strong> ${x.toFixed(6)}<br>
        `;
        document.getElementById("infoPanelCam").innerHTML = `
          <strong>Enlem:</strong> ${y.toFixed(6)}<br>
          <strong>Boylam:</strong> ${x.toFixed(6)}<br>
        `;
        updateAltitudeIndicator(altitude);
        const altBox = document.getElementById("altitudeValueBox");
        if (altBox) altBox.textContent = `${altitude.toFixed(1)} m`;
      }

      let lastFrameTime = performance.now();
      function animateFPS() {
        const now = performance.now();
        const fps = 1000 / (now - lastFrameTime);
        lastFrameTime = now;
        updateInfoPanel(fps);
        requestAnimationFrame(animateFPS);
      }
      animateFPS();

      async function moveDroneAndCamera() {
        if (isAnimating) return;

        const curr = drone.geometry;
        const moveStep = 0.00001;
        const distance = Math.abs(curr.x - targetPos.x);

        if (distance < moveStep) {
          targetPos = new Point({
            x: targetPos.x + Math.min(Math.max(targetPos.x + (Math.random() - 0.5) * 4, 0), 120),
            y: targetPos.y + Math.min(Math.max(targetPos.y + (Math.random() - 0.5) * 4, 0), 120),
            z: Math.min(Math.max(targetPos.z + (Math.random() - 0.5) * 4, 0), 120),
            spatialReference: curr.spatialReference
          });
        }

        const dx = targetPos.x - curr.x;
        const dy = targetPos.y - curr.y;
        const angle = Math.atan2(dy, dx);
        const newX = curr.x + moveStep * Math.cos(angle);
        const newY = curr.y + moveStep * Math.sin(angle);
        const newZ = curr.z + (targetPos.z - curr.z) * 0.15;

        const nextPos = new Point({
          x: newX,
          y: newY,
          z: newZ,
          spatialReference: curr.spatialReference
        });

        drone.geometry = nextPos;
        miniMarker.geometry = nextPos;
        minimapView.center = [nextPos.x, nextPos.y];

        altitude = newZ;
        const heading = (Math.atan2(newX - prevPos.x, newY - prevPos.y) * 180 / Math.PI + 360) % 360;
        prevPos = nextPos.clone();

        isAnimating = true;
        try {
          await sceneView.goTo({
            target: drone,
            heading: heading,
            tilt: tiltAngle,
            distance: followDistance
          }, {
            animate: true,
            duration: animDuration,
            easing: "linear"
          });
        } catch (err) {
          console.warn("goTo animation interrupted");
        }
        isAnimating = false;
      }

      setInterval(moveDroneAndCamera, 120);

      function updateSpeedGauge(speed) {
        const canvas = document.getElementById("gaugeCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 35;
        const startAngle = 0.75 * Math.PI;
        const endAngle = 2.25 * Math.PI;

        const normalized = Math.min(speed, 80) / 80;
        const needleAngle = startAngle + normalized * (2 * Math.PI - startAngle - (2 * Math.PI - endAngle));
        const needleLength = radius + 5;
        const needleX = centerX + needleLength * Math.cos(needleAngle);
        const needleY = centerY + needleLength * Math.sin(needleAngle);

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(needleX, needleY);
        ctx.lineWidth = 3;
        ctx.strokeStyle = "white";
        ctx.stroke();

        document.getElementById("speedText").textContent = `${Math.round(speed)} km/h`;
      }

      function toRad(angle) {
        return angle * Math.PI / 180;
      }
      function toDeg(rad) {
        return rad * 180 / Math.PI;
      }
      function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) ** 2 +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      function distance3D(lat1, lon1, alt1, lat2, lon2, alt2) {
        const horizontalDist = haversineDistance(lat1, lon1, lat2, lon2);
        const altDiffKm = (alt2 - alt1) / 1000;
        return Math.sqrt(horizontalDist ** 2 + altDiffKm ** 2);
      }

      let lastTime = Date.now();
      let lastLat = prevPos.y;
      let lastLon = prevPos.x;
      let lastAlt = prevPos.z;
      let smoothSpeed = 0;
      const alpha = 0.2;

      function runCalculation() {
        if (!drone || !prevPos) return;

        const now = Date.now();
        const timeDifferenceSec = (now - lastTime) / 1000;

        const lat1 = lastLat;
        const lon1 = lastLon;
        const alt1 = lastAlt;

        const lat2 = drone.geometry.y;
        const lon2 = drone.geometry.x;
        const alt2 = drone.geometry.z;

        const dist = distance3D(lat1, lon1, alt1, lat2, lon2, alt2);
        const instantSpeed = dist / (timeDifferenceSec / 3600);
        smoothSpeed = alpha * instantSpeed + (1 - alpha) * smoothSpeed;

        updateSpeedGauge(smoothSpeed);

        console.log("lat1:", lat1.toFixed(6), "lat2:", lat2.toFixed(6));
        console.log("lon1:", lon1.toFixed(6), "lon2:", lon2.toFixed(6));
        console.log("alt1:", alt1.toFixed(2), "alt2:", alt2.toFixed(2));
        console.log("timeDifference (s):", timeDifferenceSec.toFixed(3));
        console.log("--------------------------------------");

        lastLat = lat2;
        lastLon = lon2;
        lastAlt = alt2;
        lastTime = now;
      }

      setInterval(runCalculation, 120);

      const camImg = document.querySelector("#camerabox img");
      const liveLabel = document.getElementById("liveLabel");
      const connectionLabel = document.getElementById("connectionLabel");

      camImg.onload = () => {
        liveLabel.style.display = "flex";
        connectionLabel.textContent = "";
      };
      
    });
  </script>
</body>
</html>